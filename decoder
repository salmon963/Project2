#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BITS_PER_CHAR 7  // 定義每個字符由 7 個位元表示

// 定義 CharInfo 結構體來儲存 CSV 中讀取的字符信息
struct CharInfo {
    unsigned char character[4]; // 儲存字符
    int count;                  // 計數出現次數
    double probability;         // 該字符出現的機率
    char bin[8];                // 該字符的二進位表示法
};

// 函數：從二進位文件中讀取 7 個位元，並將它們存儲到 bits 陣列中
void read7Bits(FILE *file, unsigned char *bits, int *bitPos, int *byte, int *bitCount) {
    *bitCount = 0;  // 每次讀取前重置 bitCount，確保從頭開始計算

    // 持續讀取直到獲得 7 個位元
    while (*bitCount < BITS_PER_CHAR) {
        // 當 bitPos 為 0 時，表示需要讀取新的一個 byte
        if (*bitPos == 0) {
            *byte = fgetc(file);  // 從文件中讀取一個 byte
            if (*byte == EOF) {   // 如果讀到檔案結尾，則停止
                break;
            }
        }

        // 將 byte 的每個位元提取出來並轉換為字符 '0' 或 '1'
        bits[*bitCount] = ((*byte >> (7 - *bitPos)) & 1) + '0';
        (*bitPos)++;  // 更新 bitPos 指向下一個位元
        (*bitCount)++;  // 計數已讀取的位元數

        // 當 bitPos 到 8（滿一個 byte）時，重置為 0 以便下一個 byte 讀取
        if (*bitPos == 8) {
            *bitPos = 0;
        }
    }
    bits[*bitCount] = '\0';  // 為位元陣列添加字串結尾符號
}

int main(int argc, char **argv) {
    // 檢查命令行參數，應該有 3 個參數：輸出文本文件、CSV 文件、二進位文件
    if (argc < 4) {
        fprintf(stderr, "用法: %s <output_txt> <input_csv> <input_bin>\n", argv[0]);
        return 1;  // 如果參數不正確，返回錯誤
    }

    // 開啟 CSV 文件供讀取
    FILE *csv = fopen(argv[2], "r");
    if (!csv) {  // 如果 CSV 文件無法開啟，打印錯誤並退出
        perror("無法開啟 CSV 檔案");
        return 1;
    }

    // 開啟二進位文件供讀取
    FILE *bin = fopen(argv[3], "rb");
    if (!bin) {  // 如果二進位文件無法開啟，打印錯誤並退出
        perror("無法開啟二進位檔案");
        fclose(csv);  // 別忘了關閉已經開啟的 CSV 文件
        return 1;
    }

    struct CharInfo charInfo[65536];  // 儲存最多 65536 個字符的信息（根據實際需求可以調整）
    int index = 0;  // 用於跟踪已讀取的字符數
    char line[256]; // 用於存儲每行的 CSV 資料

    // 從 CSV 文件讀取每行數據並填充 charInfo 結構體
    while (fgets(line, sizeof(line), csv)) {
        // 使用 strtok 解析 CSV 行，分割每個欄位
        char *token = strtok(line, ",");

        // 去除字符中的雙引號，如果有雙引號則去掉
        if (token[0] == '"') {
            token++;  // 跳過開頭的雙引號
            token[strlen(token) - 1] = '\0';  // 去除結尾的雙引號
        }

        // 將解析到的字符存入 character 欄位
        strcpy((char *)charInfo[index].character, token);

        // 解析計數（出現次數）並存入 count 欄位
        token = strtok(NULL, ",");
        charInfo[index].count = atoi(token);

        // 解析機率並存入 probability 欄位
        token = strtok(NULL, ",");
        charInfo[index].probability = atof(token);

        // 解析該字符的二進位表示法並存入 bin 欄位
        token = strtok(NULL, "\n");
        strcpy(charInfo[index].bin, token);

        index++;  // 更新索引，準備讀取下一個字符
    }

    // 開啟輸出文本文件
    FILE *txt = fopen(argv[1], "w");
    if (!txt) {  // 如果文本文件無法開啟，打印錯誤並退出
        perror("無法開啟輸出文字檔案");
        fclose(csv);  // 別忘了關閉之前開啟的文件
        fclose(bin);
        return 1;
    }

    unsigned char bits[BITS_PER_CHAR + 1] = {0};  // 用於存儲從二進位文件中讀取的 7 個位元
    int bitPos = 0;  // 用於跟踪當前位元在 byte 中的位置
    int byte = 0;    // 用於存儲從文件中讀取的 byte
    int bitCount = 0;  // 用於跟踪已讀取的位元數

    // 從二進位文件中逐個讀取 7 個位元，並進行匹配
    while (!feof(bin)) {
        read7Bits(bin, bits, &bitPos, &byte, &bitCount);  // 調用函數讀取 7 個位元
        if (feof(bin)) {  // 檢查是否到達文件末尾
            break;
        }

        // 遍歷已讀取的字符信息，檢查當前讀取的位元是否匹配
        for (int i = 0; i < index; i++) {
            if (strcmp((char *)bits, charInfo[i].bin) == 0) {
                // 特殊字符處理
                if (strcmp((char *)charInfo[i].character, "\\r") == 0) {
                    fprintf(txt, "\r");  // 如果是回車，輸出回車符
                } else if (strcmp((char *)charInfo[i].character, "\\n") == 0) {
                    fprintf(txt, "\n");  // 如果是換行，輸出換行符
                } else if (strcmp((char *)charInfo[i].character, "\\t") == 0) {
                    fprintf(txt, "\t");  // 如果是制表符，輸出制表符
                } else {
                    // 否則，輸出正常的字符
                    fprintf(txt, "%s", charInfo[i].character);
                }
                break;  // 找到匹配後，跳出循環
            }
        }
        bitCount = 0;  // 重置 bitCount 以便讀取下一個字符
    }

    // 關閉所有已打開的文件
    fclose(csv);
    fclose(bin);
    fclose(txt);

    return 0;  // 成功結束程序
}
